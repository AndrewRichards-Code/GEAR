#version 450
//#extension GL_ARB_compute_shader: enable
//#entension GL_ARB_shader_storage_buffer_object: enable

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(std430, binding = 0) buffer ss_Position
{
	vec4 Positions[1024];	
};

layout(std430, binding = 1) buffer ss_Velocities
{
	vec4 Velocities[1024];	
};

layout(rgba8, binding = 0) uniform image2D u_Image;

void main()
{
	const vec4 g = vec4(0, -9.81, 0, 0);
	const float dt = 0.01;

	uvec2 gid = gl_GlobalInvocationID.xy;
	uint count = (gid.y * 64) + gid.x;

	vec4 p = Positions[count];
	vec4 v = Velocities[count];

	vec4 p1 = p + (v * dt) + 0.5 * g * dt * dt;
	vec4 v1 = v + g * dt;

	Positions[count] = p1;
	Velocities[count] = v1;

	imageStore(u_Image, ivec2(gid), vec4(p1.xyz, 1));
}

/*
in uvec3 gl_NumWorkGroups;    Same numbers as in theglDispatchCompute call
const uvec3 gl_WorkGroupSize; Same numbers as in the layout local_size_*
in uvec3 gl_WorkGroupID;      Which workgroup this thread is in

in uvec3 gl_LocalInvocationID; Where this thread is in the current workgroup
in uvec3 gl_GlobalInvocationID; Where this thread is in all the work items
in uint gl_LocalInvocationIndex; 1D representation of the gl_LocalInvocationID(used for indexing into a shared array)
*/
